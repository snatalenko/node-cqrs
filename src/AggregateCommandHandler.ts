import { getClassName, Lock, MapAssertable } from './utils';
import {
	IAggregate,
	IAggregateConstructor,
	IAggregateFactory,
	ICommand,
	ICommandHandler,
	IContainer,
	Identifier,
	IEventSet,
	IEventStore,
	ILogger,
	IObservable,
	isIObservable
} from './interfaces';

/**
 * Aggregate command handler.
 *
 * Subscribes to event store and awaits aggregate commands.
 * Upon command receiving creates an instance of aggregate,
 * restores its state, passes command and commits emitted events to event store.
 */
export class AggregateCommandHandler<TAggregate extends IAggregate> implements ICommandHandler {

	#eventStore: IEventStore;
	#logger?: ILogger;
	#aggregateFactory: IAggregateFactory<TAggregate, any>;
	#handles: string[];

	/** Aggregate instances cache for concurrent command handling */
	#aggregatesCache: MapAssertable<Identifier, Promise<TAggregate>> = new MapAssertable();

	/** Lock for sequential aggregate command execution */
	#executionLock = new Lock();

	constructor({
		eventStore,
		aggregateType,
		aggregateFactory,
		handles,
		logger
	}: Pick<IContainer, 'eventStore' | 'logger'> & {
		aggregateType?: IAggregateConstructor<TAggregate, any>,
		aggregateFactory?: IAggregateFactory<TAggregate, any>,
		handles?: string[]
	}) {
		if (!eventStore)
			throw new TypeError('eventStore argument required');

		this.#eventStore = eventStore;
		this.#logger = logger && 'child' in logger ?
			logger.child({ service: getClassName(this) }) :
			logger;

		if (aggregateType) {
			const AggregateType = aggregateType;
			this.#aggregateFactory = params => new AggregateType(params);
			this.#handles = AggregateType.handles;
		}
		else if (aggregateFactory) {
			if (!Array.isArray(handles) || !handles.length)
				throw new TypeError('handles argument must be an non-empty Array');

			this.#aggregateFactory = aggregateFactory;
			this.#handles = handles;
		}
		else {
			throw new TypeError('either aggregateType or aggregateFactory is required');
		}
	}

	/** Subscribe to all command types handled by aggregateType */
	subscribe(commandBus: IObservable) {
		if (!commandBus)
			throw new TypeError('commandBus argument required');
		if (!isIObservable(commandBus))
			throw new TypeError('commandBus argument must implement IObservable interface');

		for (const commandType of this.#handles)
			commandBus.on(commandType, (cmd: ICommand) => this.execute(cmd));
	}

	/** Restore aggregate from event store events */
	async #restoreAggregate(id: Identifier): Promise<TAggregate> {
		if (!id)
			throw new TypeError('id argument required');

		const eventsIterable = this.#eventStore.getAggregateEvents(id);
		const aggregate = this.#aggregateFactory({ id });

		let eventCount = 0;
		for await (const event of eventsIterable) {
			aggregate.mutate(event);
			eventCount += 1;
		}

		this.#logger?.info(`${aggregate} state restored from ${eventCount} event(s)`);

		return aggregate;
	}

	/** Create new aggregate with new Id generated by event store */
	async #createAggregate(): Promise<TAggregate> {
		const id = await this.#eventStore.getNewId();
		const aggregate = this.#aggregateFactory({ id });
		this.#logger?.info(`${aggregate} created`);

		return aggregate;
	}

	async #getAggregateInstance(aggregateId?: Identifier) {
		if (!aggregateId)
			return this.#createAggregate();
		else
			return this.#aggregatesCache.assert(aggregateId, () => this.#restoreAggregate(aggregateId));
	}

	/** Pass a command to corresponding aggregate */
	async execute(cmd: ICommand): Promise<IEventSet> {
		if (!cmd)
			throw new TypeError('cmd argument required');
		if (!cmd.type)
			throw new TypeError('cmd.type argument required');

		// create new or get cached aggregate instance promise
		// multiple concurrent calls to #getAggregateInstance will return the same promise
		const aggregate = await this.#getAggregateInstance(cmd.aggregateId);

		try {
			// pass command to aggregate instance
			// multiple concurrent calls will execute sequentially
			const events = await this.#executionLock.runExclusively(String(aggregate.id), async () => {
				await aggregate.handle(cmd);

				if (aggregate.shouldTakeSnapshot)
					aggregate.takeSnapshot?.();

				return aggregate.popChanges();
			});

			this.#logger?.info(`${aggregate} "${cmd.type}" command processed, ${events.length} event(s) produced`);

			if (events.length)
				await this.#eventStore.dispatch(events);

			return events;
		}
		finally {
			this.#aggregatesCache.release(aggregate.id);
		}
	}
}
